**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `devnet`
- **Package ID:** `0x8116a7e1c135875e1113e4f250e1d251fca489610c9a55d7c7b4dceeb98a3b2d`
- **Module Name:** `contract`
- **Available Methods:**

  * `create` (constant: `CREATE`)
  * `add_bookmark` (constant: `ADD_BOOKMARK`)
  * `remove_bookmark` (constant: `REMOVE_BOOKMARK`)
  * `get_bookmark_count` (constant: `GET_BOOKMARK_COUNT`)

---

# **Move Contract: `contract/bookmarkmanager/sources/bookmarkmanager.move`**

```move
module bookmarkmanager::contract {
public struct Bookmarkmanager has key {
id: UID,
owner: address,
bookmark_count: u64
}
public fun create(ctx: &mut TxContext) {
transfer::share_object(Bookmarkmanager {
id: object::new(ctx),
owner: ctx.sender(),
bookmark_count: 0
})
}
public fun add_bookmark(manager: &mut Bookmarkmanager, ctx: &TxContext) {
assert!(manager.owner == ctx.sender(), 0);
manager.bookmark_count = manager.bookmark_count + 1;
}
public fun remove_bookmark(manager: &mut Bookmarkmanager, ctx: &TxContext) {
assert!(manager.owner == ctx.sender(), 0);
assert!(manager.bookmark_count > 0, 1);
manager.bookmark_count = manager.bookmark_count - 1;
}
public fun get_bookmark_count(manager: &Bookmarkmanager): u64 {
manager.bookmark_count
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client"

/**
 * ============================================================================
 * BOOKMARK MANAGER CONTRACT INTEGRATION HOOK
 * ============================================================================
 */

import { useState, useEffect } from "react"
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from "@iota/dapp-kit"
import { Transaction } from "@iota/iota-sdk/transactions"
import { useNetworkVariable } from "@/lib/config"
import type { IotaObjectData } from "@iota/iota-sdk/client"

export const CONTRACT_MODULE = "contract"
export const CONTRACT_METHODS = {
  CREATE: "create",
  ADD_BOOKMARK: "add_bookmark",
  REMOVE_BOOKMARK: "remove_bookmark",
} as const

function getObjectFields(data: IotaObjectData): { bookmark_count: number; owner: string } | null {
  if (data.content?.dataType !== "moveObject") {
    return null
  }
  
  const fields = data.content.fields as any
  if (!fields) return null
  
  let bookmark_count: number
  if (typeof fields.bookmark_count === "string") {
    bookmark_count = parseInt(fields.bookmark_count, 10)
    if (isNaN(bookmark_count)) return null
  } else if (typeof fields.bookmark_count === "number") {
    bookmark_count = fields.bookmark_count
  } else {
    return null
  }
  
  if (!fields.owner) return null
  const owner = String(fields.owner)
  
  return { bookmark_count, owner }
}

export interface ContractData {
  bookmark_count: number
  owner: string
}

export interface ContractState {
  isLoading: boolean
  isPending: boolean
  isConfirming: boolean
  isConfirmed: boolean
  hash: string | undefined
  error: Error | null
}

export interface ContractActions {
  createObject: () => Promise<void>
  addBookmark: () => Promise<void>
  removeBookmark: () => Promise<void>
  clearObject: () => void
}

export const useContract = () => {
  const currentAccount = useCurrentAccount()
  const address = currentAccount?.address
  const packageId = useNetworkVariable("packageId")
  const iotaClient = useIotaClient()
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction()
  const [objectId, setObjectId] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hash, setHash] = useState<string | undefined>()
  const [transactionError, setTransactionError] = useState<Error | null>(null)

  useEffect(() => {
    if (typeof window !== "undefined") {
      const hash = window.location.hash.slice(1)
      if (hash) setObjectId(hash)
    }
  }, [])

  const { data, isPending: isFetching, error: queryError, refetch } = useIotaClientQuery(
    "getObject",
    {
      id: objectId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!objectId,
    }
  )

  const fields = data?.data ? getObjectFields(data.data) : null
  const isOwner = fields?.owner.toLowerCase() === address?.toLowerCase()
  const objectExists = !!data?.data
  const hasValidData = !!fields

  const createObject = async () => {
    if (!packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      setHash(undefined)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.CREATE}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              })
              const newObjectId = effects?.created?.[0]?.reference?.objectId
              if (newObjectId) {
                setObjectId(newObjectId)
                if (typeof window !== "undefined") {
                  window.location.hash = newObjectId
                }
                setIsLoading(false)
              } else {
                setIsLoading(false)
              }
            } catch (waitError) {
              console.error("Error waiting for transaction:", waitError)
              setIsLoading(false)
            }
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      setIsLoading(false)
    }
  }

  const addBookmark = async () => {
    if (!objectId || !packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.object(objectId)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.ADD_BOOKMARK}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      setIsLoading(false)
    }
  }

  const removeBookmark = async () => {
    if (!objectId || !packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.object(objectId)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.REMOVE_BOOKMARK}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      setIsLoading(false)
    }
  }

  const contractData: ContractData | null = fields
    ? {
        bookmark_count: fields.bookmark_count,
        owner: fields.owner,
      }
    : null

  const clearObject = () => {
    setObjectId(null)
    setTransactionError(null)
    if (typeof window !== "undefined") {
      window.location.hash = ""
    }
  }

  const actions: ContractActions = {
    createObject,
    addBookmark,
    removeBookmark,
    clearObject,
  }

  const contractState: ContractState = {
    isLoading: (isLoading && !objectId) || isPending || isFetching,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  }

  return {
    data: contractData,
    actions,
    state: contractState,
    objectId,
    isOwner,
    objectExists,
    hasValidData,
  }
}

```

---

# File 2: `components/sample.tsx`

```tsx
"use client"

import { useCurrentAccount } from "@iota/dapp-kit"
import { useContract } from "@/hooks/useContract"
import { Button, Container, Flex, Heading, Text, Card, Badge } from "@radix-ui/themes"
import ClipLoader from "react-spinners/ClipLoader"

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount()
  const { data, actions, state, objectId, isOwner, objectExists, hasValidData } = useContract()
  
  const isConnected = !!currentAccount

  if (!isConnected) {
    return (
      <div style={{ minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", padding: "1rem" }}>
        <Card style={{ maxWidth: "500px", width: "100%", padding: "2rem" }}>
          <Heading size="6" style={{ marginBottom: "1rem" }}>ðŸ”– Bookmark Manager</Heading>
          <Text>Please connect your wallet to start managing your bookmarks on the blockchain.</Text>
        </Card>
      </div>
    )
  }

  return (
    <div style={{ minHeight: "100vh", padding: "2rem", background: "var(--gray-a2)" }}>
      <Container style={{ maxWidth: "800px", margin: "0 auto" }}>
        <Heading size="8" style={{ marginBottom: "0.5rem" }}>ðŸ”– Bookmark Manager</Heading>
        <Text size="3" style={{ color: "var(--gray-a11)", marginBottom: "2rem", display: "block" }}>
          Manage your bookmarks securely on the IOTA blockchain
        </Text>

        {!objectId ? (
          <Card style={{ padding: "2rem" }}>
            <Text size="4" style={{ marginBottom: "1rem", display: "block" }}>
              Create your bookmark manager to get started
            </Text>
            <Button
              size="3"
              onClick={actions.createObject}
              disabled={state.isPending}
            >
              {state.isPending ? (
                <>
                  <ClipLoader size={16} style={{ marginRight: "8px" }} />
                  Creating...
                </>
              ) : (
                "Create Bookmark Manager"
              )}
            </Button>
            {state.error && (
              <div style={{ marginTop: "1rem", padding: "1rem", background: "var(--red-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--red-11)" }}>
                  Error: {(state.error as Error)?.message || String(state.error)}
                </Text>
              </div>
            )}
          </Card>
        ) : (
          <div>
            {state.isLoading && !data ? (
              <Card style={{ padding: "2rem", textAlign: "center" }}>
                <ClipLoader size={32} />
                <Text style={{ display: "block", marginTop: "1rem" }}>Loading bookmark manager...</Text>
              </Card>
            ) : state.error ? (
              <Card style={{ padding: "2rem", background: "var(--red-a3)" }}>
                <Text style={{ color: "var(--red-11)", display: "block", marginBottom: "0.5rem" }}>
                  Error loading bookmark manager
                </Text>
                <Text size="2" style={{ color: "var(--red-11)" }}>
                  {state.error.message || "Object not found or invalid"}
                </Text>
                <Button
                  size="2"
                  variant="soft"
                  onClick={actions.clearObject}
                  style={{ marginTop: "1rem" }}
                >
                  Clear & Create New
                </Button>
              </Card>
            ) : data ? (
              <div>
                <Card style={{ padding: "2rem", marginBottom: "1.5rem" }}>
                  <Flex justify="between" align="center" style={{ marginBottom: "1rem" }}>
                    <div>
                      <Text size="2" style={{ display: "block", marginBottom: "0.5rem", color: "var(--gray-a11)" }}>
                        Total Bookmarks
                      </Text>
                      <Heading size="9">{data.bookmark_count}</Heading>
                    </div>
                    {isOwner && (
                      <Badge color="green" size="2">Owner</Badge>
                    )}
                  </Flex>
                  <Text size="1" style={{ color: "var(--gray-a11)", fontFamily: "monospace", wordBreak: "break-all" }}>
                    Manager ID: {objectId}
                  </Text>
                </Card>

                {isOwner && (
                  <Card style={{ padding: "1.5rem", marginBottom: "1.5rem" }}>
                    <Text size="4" style={{ marginBottom: "1rem", display: "block", fontWeight: "500" }}>
                      Manage Bookmarks
                    </Text>
                    <Flex gap="2">
                      <Button
                        size="3"
                        onClick={actions.addBookmark}
                        disabled={state.isLoading || state.isPending}
                        style={{ flex: 1 }}
                      >
                        {state.isLoading || state.isPending ? (
                          <ClipLoader size={16} />
                        ) : (
                          "âž• Add Bookmark"
                        )}
                      </Button>
                      <Button
                        size="3"
                        variant="soft"
                        color="red"
                        onClick={actions.removeBookmark}
                        disabled={state.isLoading || state.isPending || data.bookmark_count === 0}
                        style={{ flex: 1 }}
                      >
                        {state.isLoading || state.isPending ? (
                          <ClipLoader size={16} />
                        ) : (
                          "âž– Remove Bookmark"
                        )}
                      </Button>
                    </Flex>
                  </Card>
                )}

                {state.hash && (
                  <Card style={{ padding: "1.5rem", marginBottom: "1rem", background: "var(--green-a3)" }}>
                    <Text size="2" style={{ display: "block", marginBottom: "0.5rem", fontWeight: "500" }}>
                      Transaction Hash
                    </Text>
                    <Text size="1" style={{ fontFamily: "monospace", wordBreak: "break-all" }}>{state.hash}</Text>
                    {state.isConfirmed && (
                      <Badge color="green" style={{ marginTop: "0.5rem" }}>
                        âœ“ Transaction confirmed!
                      </Badge>
                    )}
                  </Card>
                )}

                {state.error && (
                  <Card style={{ padding: "1.5rem", background: "var(--red-a3)" }}>
                    <Text style={{ color: "var(--red-11)" }}>
                      Error: {(state.error as Error)?.message || String(state.error)}
                    </Text>
                  </Card>
                )}
              </div>
            ) : (
              <Card style={{ padding: "2rem" }}>
                <Text style={{ color: "var(--yellow-11)" }}>Bookmark manager not found</Text>
                <Button
                  size="2"
                  variant="soft"
                  onClick={actions.clearObject}
                  style={{ marginTop: "1rem" }}
                >
                  Clear & Create New
                </Button>
              </Card>
            )}
          </div>
        )}
      </Container>
    </div>
  )
}

export default SampleIntegration

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0x8116a7e1c135875e1113e4f250e1d251fca489610c9a55d7c7b4dceeb98a3b2d` and Module: `contract`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
